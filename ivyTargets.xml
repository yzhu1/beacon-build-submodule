<?xml version="1.0"?>
<project name="ivy" xmlns:ivy="antlib:org.apache.ivy.ant" basedir=".">

    <taskdef resource="net/sf/antcontrib/antlib.xml">
        <classpath><pathelement path="${build.lib.dir}/ant-contrib.jar"/></classpath>
    </taskdef>

    <property environment="sys_env" />
    <property file="${app.config.dir}/version.properties" />
    <!-- pick up DPP/13 compliant version numbers from version.properties, and append BUILD_NUMBER (set by Jenkins) -->
    <property name="module.revision.dev" value="dev" />
    <if>
        <isset property="module.revision.major"/>
        <then>
            <if>
            <!-- if the BUILD_NUMBER is set, we are in Jenkins-land: use the DPP/13 version.  If not, assume "dev" -->
                <isset property="sys_env.BUILD_NUMBER" />
                <then>
                    <property name="module.revision.published" value="${module.revision.major}.${module.revision.minor}.${module.revision.revision}-${sys_env.BUILD_NUMBER}" />
                </then>
                <else>
                    <property name="module.revision.published" value="${module.revision.dev}" />
                </else>
            </if>
        </then>
        <else>
            <property name="module.revision.published" value="${project.revision}" />
        </else>
    </if>

    <!-- these imports aren't necessary but eclipse displays errors if they're not here-->
    <import file="deployTargets.xml"/>
    <import file="dbTargets.xml"/>
    <!-- this one is totally necessary, though -->
    <include file="gitMacros.xml" />



    <target name="clean-ivy" depends="clean-ivy-local-repo-jar, clean-ivy-local-repo-web-assets">
        <delete dir="${ivy.lib.dir}" includeemptydirs="true" failonerror="false" />
        <delete file="${ivy.settings.dir}/ivysettings.xml"/>
    </target>

    <target name="clean-ivy-local-repo-jar">
        <delete dir="${ivy.local.repo.dir}/${org.name}/${project.name}" includeemptydirs="true" failonerror="false" />
    </target>

    <target name="clean-ivy-local-repo-web-assets">
        <delete dir="${ivy.local.repo.dir}/${org.name}/${project.name}-web-assets" includeemptydirs="true" failonerror="false" />
    </target>

    <target name="init-ivy" depends="ivy-get-settings, ivy-resolve"/>

    <target name="ivy-get-settings" description="--> retrieve ivysettings.xml from server">
        <ivy:settings id="bootstrap-settings" file="${imported.basedir}/bootstrap-ivy-settings.xml" />
        <ivy:resolve settingsRef="bootstrap-settings" file="${imported.basedir}/bootstrap-ivy-module.xml" />
        <ivy:retrieve settingsRef="bootstrap-settings" pattern="${ivy.settings.dir}/[artifact].[ext]"/>
    </target>

    <target name="ivy-resolve" description="--> retrieve dependencies with ivy" depends="ivy-get-settings, ivy-clean-resolution-cache">
        <ivy:settings id="ivy.settings" file="${ivy.settings.dir}/ivysettings.xml" />
        <!-- copy artifacts from repo(s) to cache -->
        <ivy:resolve settingsRef="ivy.settings" file="${ivy.module.file}" />
        <!-- copy artifacts from cache to destination dir -->
        <ivy:retrieve settingsRef="ivy.settings" sync="true" overwriteMode="always"/>
        <mkdir dir="${ivy.report.dir}" />
        <ivy:report todir="${ivy.report.dir}" xsl="true" xml="true" graph="true" dot="true"/>
        <if>
            <isfalse value="${use.eclipse.ivyde.plugin}" />
                <then>
                    <antcall target="rebuild-eclipse-classpath" />
                </then>
        </if>
    </target>

    <target name="rebuild-eclipse-classpath" description="gets run by ivy-resolve if you have use.eclipse.ivyde.plugin=false">
        <if>
            <isset property="cygwin.bash" />
            <then>
                <path id="basedir.path"><pathelement path="${basedir}"/></path>
                <pathconvert targetos="unix" property="basedir.unix" refid="basedir.path"/>
                <exec executable="${cygwin.bash}">
                    <arg value="--login"/>
                    <arg value="-i"/>
                    <arg value="-c"/>
                    <arg value="cd ${basedir.unix}; python ${app.config.dir}/base/scripts/dev/rebuild_eclipse_classpath.py ${app.config.dir}/eclipse.classpath.header" />
                </exec>
            </then>
            <else>
                <exec executable="/usr/bin/python" dir="${basedir}">
                    <arg value="${common.config.dir}/scripts/dev/rebuild_eclipse_classpath.py" />
                    <arg value="${app.config.dir}/eclipse.classpath.header" />
                </exec>
            </else>
        </if>
    </target>


    <!-- WARNING: Use this with target with caution.
  
                  It will delete all caches, including the resolution cache 
                  as well as the repository cache.
                  If there are several projects that share the same repository
                  cache, then deleting it may cause the other projects to
                  fail unexpectedly.
    -->
    <target name="ivy-clean-all-caches">
        <echo>cleaning ALL ivy caches</echo>
        <ivy:cleancache />
    </target>

    <target name="ivy-clean-resolution-cache" if="update.ivy.dependencies">
        <delete dir="${ivy.resolution.cache.dir}" />
    </target>

    <target name="ivy-publish"
            description="Run unit tests, build jar/zip files, and publish to ivy"
            depends="clean, clean-ivy, init-ivy, checkstyle, test-frontend, test-unit, build-app-jars, build-test-jars, zip-web-assets, ivy-get-settings">
        <publish resolver="ivyrepo"/>
    </target>

    <target name="ivy-publish-only" description="Publish to ivy repo, assuming that all resolution, testing and compilation has already been done"
            depends="build-app-jars,build-test-jars,zip-web-assets">
        <publish resolver="ivyrepo" />
    </target>

    <target name="ivy-publish-dev"
            description="Run unit tests, build jar/zip files, and publish to local repository"
            depends="clean, clean-ivy, init-ivy, checkstyle, test-frontend, test-unit, build-app-jars, build-test-jars, zip-web-assets, ivy-get-settings">
        <publish resolver="localrepo" />
    </target>

    <target name="ivy-publish-only-dev" depends="build-app-jars, build-test-jars, zip-web-assets"
            description="Run ivy-publish-dev without first running ivy-resolve and tests, to save time and aggravation (only run it after running publish-dev normally once)">
        <publish resolver="localrepo" />
    </target>
    <target name="ivy-publish-repeat"><echo>RENAMED: to 'ivy-publish-only-dev', to better reflect how it fits into the build ecosystem</echo></target>

    <target name="ivy-clean-deploy-steps" depends="clean, ivy-resolve, unzip-web-assets, deploy"/>

    <macrodef name="publish">
        <attribute name="settingsFile" default="${ivy.settings.dir}/ivysettings.xml" />
        <attribute name="resolver" /> <!-- no default! -->
        <attribute name="revision" default="${module.revision.published}" />
        <element name="artifact-nested" optional="true" implicit="true" />
        <sequential>
            <ivy:settings id="ivy.settings" file="@{settingsFile}" />
            <ivy:publish
                settingsRef="ivy.settings"
                update="true"
                overwrite="true"
                forcedeliver="true"
                resolver="@{resolver}"
                organisation="${project.organization}"
                module="${project.name}"
                revision="@{revision}"
                >
                <artifact-nested /> <!-- if empty, only the default artifacts will publish -->
                <artifacts pattern="${build.artifacts.dir}/[artifact].[ext]" />
                <artifacts pattern="${build.artifacts.dir}/test/[artifact].[ext]" />
            </ivy:publish>
        </sequential>
    </macrodef>

    <!-- not technically ivy-related -->
    <target name="update-commit-log">
        <!-- set job ID to a placeholder if not actually running in Jenkins (for debugging) -->
        <condition
                property="jenkins.job-id"
                else="FAKE_JENKINS_JOB"
                value="${sys_env.JOB_NAME}-${sys_env.BUILD_NUMBER}">
            <isset property="sys_env.JOB_NAME" />
        </condition>
        <git-retrieve-branch-name />
        <git-retrieve-commit-id />
        <property name='log-message'
          value="build ${jenkins.job-id} built ${git.current.commit} as ${module.revision.published}${line.separator}"
        />
        <echo>Pulling from ${git.current.branch}</echo>
        <git command="pull"><arg value="origin" /> <arg value="${git.current.branch}" /></git>
        <echo message="${git.command.output}"/>
        <echo append="true" file=".commitlog" message="${log-message}" />
    </target>

    <target name="push-commit-log">
        <git-retrieve-branch-name />
        <git command="commit">
            <arg value="-m" />
            <arg value="update .commitlog" />
            <arg value=".commitlog" />
        </git>
        <git-push-to-branch branchname="${git.current.branch}" />
        <echo message="${git.command.output}" />
    </target>

    <!-- this has some limitations, thanks to XML not handling "null" very well: project.organization *must* be set,
         and module.branch *must* be in use.  If we really want to use this for non-branched repos, we can change
         the core section to branch on whether module.branch is set, and either set or not set that value on each
         task depending on the branch, but for now, let's not.
    -->
    <target name="verify-patch-level-public-api-compatibility"
            description="verify that no breaking public api changes have been introduced for this patch level.  Works only for branched ivy repos."
            depends="verify-patch-level-changelog-entry, build-app-jars, build-test-jars">

      <property name="current.revision" value="${module.revision.major}.${module.revision.minor}.${module.revision.revision}-+" />
      <ivy:findrevision organisation="${project.organization}" module="${project.name}" revision="${current.revision}"
                        property="published.revision" branch="${module.branch}" />
        <if>
            <isset property="published.revision" />
            <then>
                <echo message="Found revision ${published.revision}" />
                <ivy:resolve refresh="true" inline="true" keep="true"
                  organisation="${project.organization}"
                  module="${project.name}"
                  revision="${published.revision}"
                  branch="${module.branch}"
                  transitive="false"
                  resolveId="apivalidate"
                  log="quiet"
                  haltonfailure="true"
                />
                <ivy:retrieve inline="true"
                  organisation="${project.organization}"
                  module="${project.name}"
                  revision="${published.revision}"
                  branch="${module.branch}"
                  transitive="false"
                  resolveId="apivalidate"
                  pattern="target/baseline-jars/[revision]/[artifact].[ext]"
                  type="jar"
                />
                <exec executable="${common.config.dir}/scripts/build/api-compatibility/api-compatibility-check.sh" failonerror="true" >
                   <arg value="${published.revision}" />
                </exec>
            </then>
            <else>
                <echo message="No previous publication matches ${current.revision}: go nuts." />
            </else>
        </if>
    </target>

    <target name="verify-patch-level-changelog-entry" description="make sure that the CHANGELOG contains an entry for the current patchlevel">
      <exec executable="grep" failonerror="true">
        <arg value="-q" />
        <arg value="VERSION ${module.revision.major}.${module.revision.minor}.${module.revision.revision}" />
        <arg file="CHANGELOG" />
      </exec>
    </target>

</project>
